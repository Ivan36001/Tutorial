package Новый_курс;

import java.util.*;

//Т.о в Map уникальны ключи, а в Set-элементы
public class HashCodeEquals {
    public static void main(String[] args) {
        Map<Person,String> map=new HashMap<>();
        Set<Person> set=new HashSet<>();
        Person person1=new Person(1, "Mike");//по умолчанию java не смотрит на поля класса
        Person person2=new Person(1, "Mike");// не лезет в реализацию класса, поэтому для нее
        //это разные объекты (т.к разные участки памяти). Для стандартных объектов типа String  и Integer
        // так не происходит (т.е при добавлении в множество двух одинаковых строк добавится только одна т.к
        // методы equals() и hashCode() переопределены. А у нас не переопределенные методы наследованные
        //от класса Object.
        map.put(person1, "123");
        map.put(person2, "123");
        set.add(person1);
        set.add(person2);
        System.out.println(map);// при выводе выйдут два одинаковых ключа: Person{id=1, name='Mike'}
        System.out.println(set);// при выводе выйдут два одинаковых объекта: Person{id=1, name='Mike'}

    }
}
class Person{
    private int id;
    private String name;

    public Person(int id, String name) {//переопределили конструктор по умолчанию чтобы на вход принимал
        //id и Name
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {//переопределили метод toString(), чтобы выводил Имя и id на печать
        return "Person{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
    //Добавим в класс Person два переопределенных метода equals() и hashCode() для
    // различения двух объектов person1 и person2 по полям id и name
    // (добавляются ПКМ-Generate-equals() and hashCode()):


   // @Override
    //public boolean equals(Object o) {
    //    if (this == o) return true;
    //    if (o == null || getClass() != o.getClass()) return false;
    //    Person person = (Person) o;
    //    return id == person.id &&
    //            Objects.equals(name, person.name);
    //}

    //@Override
    //public int hashCode() {
    //    return Objects.hash(id, name);
    //}
}
//КОНТРАКТ hashCode() equals():
//1) У двух проверяемых объектов вызывается вначале метод hashCode() который преобразует объект в число int
//выполняется очень быстро поэтому вызывается первым. Если хэшкоды разные объекты точно разные
// и метод equals() не выполняется.
//2)Если хэши одинаковые то для проверки не возникла ли коллизия (т.к. кол-во числел int ограничено,а
//комбинаций объектов может быть очень много может для двух разных объектов выдаться одинаковый хэш)
//вызывается метод equals() который проверяет все поля объекта (работает долого) и выдает точный результат
//сравнения
// В java класс HeshSet в своей реализации использует HashMap (пользуется уникальностью ключей и использует
//их в качестве своих значений). Поэтому рассмотрим реализацию именно HashMap.
//HashMap состоит из массива в каждой ячейке которого лежит связанный список linkedList
//каждый узел linkedList имеет следующие поля: 1)int hash-хэш текущего элемента 2)K key-ключ текущего эл-та
//3)V value-значение текущего элемента 4) Node<k,v> next-ссылка на след. узел.Добавим в HashMap пару
//ключ-значение: При вызове метода put(): у нашего ключа будет вычеслен хэш (т.е используется метод hashCode)
//Далее наш хэш побитово умножаем на размер массива минус один (n-1) эта операция гарантированно возвращает
//число в пределах нашего массива (от 0 до n) которое будет индексом ячейки куда мы положим ключ-значение.
// Если для другой пары ключ-значение индекс совпал с какой-либо предыдущей, мы добавляем новую пару в ту же
//ячейку массива, а первый добавленный узел (пара) приобретает ссылку на новый узел реализуя таки образом
// linkedList (новый узел добавляется в конец списка)
// Для получения элемента по ключу (метод get()): Мы текже вычисляем хэш для ключа, затем производим
//побитовое умножение для получения индекса нужной ячейки (что очень бысто- не надо проходится по всем
//ячейкам массива). Далее сравниваются хэши для каждого узла linkedList-а в ячейке массива, при  совпадении
// хэшей сравниваем ключи методом equals() для реализации КОНТРАКТа hashCode() equals() если мы убеждаемся
//что это нужный узел-возвращаем значение соответствующее ключу.
